<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egzamin Administratora Linux - Test Wiedzy</title>
    <style>
        :root { --primary: #e95420; --bg: #f5f6fa; --card: #ffffff; --text: #2d3436; --correct: #00b894; --wrong: #d63031; --primary-dark: #c0392b; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; padding-bottom: 60px; }
        
        h1 { 
            text-align: center; 
            color: #2c3e50; 
            margin-bottom: 40px; 
            font-size: 2.2em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Karta pytania */
        .q-card { 
            background: var(--card); 
            padding: 30px; 
            margin-bottom: 30px; 
            border-radius: 12px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.05); 
            border-left: 6px solid var(--primary); 
            transition: transform 0.2s;
        }
        .q-card:hover { transform: translateY(-2px); }

        .q-header { 
            font-weight: 700; 
            font-size: 1.2em; 
            margin-bottom: 25px; 
            color: #2c3e50; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .badge { 
            background: #dfe6e9; 
            font-size: 0.75em; 
            padding: 4px 10px; 
            border-radius: 20px; 
            color: #636e72; 
            font-weight: 600; 
            white-space: nowrap;
            margin-left: 15px;
        }

        /* Lista opcji */
        .options-list { display: flex; flex-direction: column; gap: 10px; }
        
        .opt-label { 
            display: flex; 
            align-items: center; 
            padding: 15px; 
            border: 2px solid #e1e1e1; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.2s ease; 
            background: #fff; 
            font-size: 1em;
        }
        
        .opt-label:hover { background: #fdfdfd; border-color: #b2bec3; }
        
        /* Stylizacja checkboxa */
        .opt-label input { 
            margin-right: 15px; 
            width: 20px; 
            height: 20px; 
            cursor: pointer;
            accent-color: var(--primary);
        }

        /* Style walidacji */
        .opt-label.correct { border-color: var(--correct); background: #e3fcf7; color: #006b54; font-weight: 600; }
        .opt-label.wrong { border-color: var(--wrong); background: #fff0f0; color: #c0392b; }
        
        /* Styl dla poprawnej odpowiedzi, której użytkownik NIE zaznaczył */
        .opt-label.missed { border: 2px dashed var(--correct); background: #f0fffa; opacity: 0.8; }

        /* Przycisk */
        .btn-check { 
            background: var(--primary); 
            color: #fff; 
            border: none; 
            padding: 12px 30px; 
            font-size: 1em; 
            font-weight: 600;
            border-radius: 6px; 
            cursor: pointer; 
            margin-top: 25px; 
            transition: background 0.3s; 
            display: inline-block;
        }
        .btn-check:hover { background: var(--primary-dark); }

        .score-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #2d3436;
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-weight: bold;
            z-index: 100;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Egzamin Administratora Linux</h1>
    <div id="quiz-area"></div>
</div>
<div style="font-family: sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px;">

    <p>Zrozumiałem. Przechodzimy na poziom „Expert Mode”. Egzaminy tego typu często sprawdzają nie tylko to, „co” się dzieje, ale „dlaczego” tak się dzieje pod maską. Aby odpowiedzieć na podchwytliwe pytania, musisz rozumieć mechanizmy jądra (kernela).</p>
    
    <p>Oto kompleksowe kompendium wiedzy, które wykracza poza pytania testowe, wyjaśniając architekturę systemu Linux.</p>

    <hr style="border: 0; border-top: 1px solid #ccc; margin: 20px 0;">

    <h2 style="color: #0056b3;">CZĘŚĆ I: Architektura i Jądro Systemu (Fundamenty)</h2>
    <p>Zrozumienie tego działu jest kluczowe dla pytań o "obowiązki administratora" i "wpływ na system".</p>

    <h3 style="color: #333;">1. Jądro (Kernel) – Serce Systemu</h3>
    <p>To nie jest tylko "program zarządzający sprzętem". Kernel działa w uprzywilejowanym trybie procesora (<strong>Ring 0</strong>), podczas gdy wszystko inne (przeglądarka, serwer WWW, Twoja powłoka bash) działa w przestrzeni użytkownika (<strong>Ring 3</strong>).</p>
    <ul>
        <li><strong>System Call (Wywołanie systemowe):</strong> Gdy program chce zapisać plik lub wysłać pakiet, nie robi tego sam. Prosi o to jądro poprzez syscall (np. <code>read()</code>, <code>write()</code>, <code>fork()</code>).</li>
        <li><strong>Monolityczna architektura:</strong> W Linuxie sterowniki, obsługa sieci i systemy plików są częścią jądra (ładowane dynamicznie jako moduły <code>.ko</code>), co zapewnia wydajność, ale błąd w sterowniku może wywalić cały system (Kernel Panic).</li>
    </ul>

    <h3 style="color: #333;">2. Przestrzeń Użytkownika (User Space)</h3>
    <p>Tu działają procesy. Administrator zarządza tą warstwą, konfigurując, jak procesy rozmawiają z jądrem.</p>
    <ul>
        <li><strong>Shell (Powłoka):</strong> To tylko interfejs tekstowy do jądra. Bash, Zsh, Sh to programy, które interpretują Twoje polecenia i uruchamiają inne programy.</li>
    </ul>

    <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

    <h2 style="color: #0056b3;">CZĘŚĆ II: Procesy, Wątki i Zarządzanie Zasobami</h2>
    <p>Pytania o "procesy potomne", "zużycie zasobów" i "wątki" wymagają wiedzy o cyklu życia procesu.</p>

    <h3 style="color: #333;">1. Anatomia Procesu</h3>
    <p>Proces to "kontener" na zasoby. Każdy proces posiada:</p>
    <ul>
        <li><strong>PID (Process ID):</strong> Unikalny numer.</li>
        <li><strong>Przestrzeń adresową:</strong> Wirtualną pamięć, której proces "myśli", że jest właścicielem (izolacja).</li>
        <li><strong>Tablicę deskryptorów plików (File Descriptors - FD):</strong> Lista otwartych zasobów (pliki, gniazda sieciowe, potoki).<br>
        <em>Kluczowe:</em> Standardowe FD to 0 (stdin), 1 (stdout), 2 (stderr).</li>
        <li><strong>Kontekst bezpieczeństwa:</strong> UID (kto uruchomił), GID, eUID (efektywny użytkownik - ważny przy SUID).</li>
    </ul>

    <h3 style="color: #333;">2. Cykl Życia: Fork() i Exec()</h3>
    <p>To mechanizm tworzenia nowych procesów (pytanie o dziedziczenie).</p>
    <ul>
        <li><strong>Fork():</strong> Proces rodzic klonuje samego siebie. Powstaje proces potomny (Child).
            <ul>
                <li><em>Co jest dziedziczone?</em> Wszystkie otwarte deskryptory plików (dlatego potomek może pisać do tego samego pliku co rodzic), zmienne środowiskowe, aktualny katalog.</li>
                <li><em>CoW (Copy on Write):</em> Pamięć nie jest kopiowana fizycznie od razu. Jest kopiowana dopiero, gdy potomek próbuje coś w niej zmienić. To optymalizacja.</li>
            </ul>
        </li>
        <li><strong>Exec():</strong> Potomek podmienia swój kod nowym programem (np. poleceniem <code>ls</code>).</li>
    </ul>

    <h3 style="color: #333;">3. Stany Procesu (Diagnostyka "ps aux" i "top")</h3>
    <p>Gdy analizujesz "nadmierne zużycie zasobów", musisz znać stany:</p>
    <ul>
        <li><strong>R (Running/Runnable):</strong> Działa na CPU lub czeka w kolejce do CPU.</li>
        <li><strong>S (Sleeping):</strong> Czeka na zdarzenie (np. naciśnięcie klawisza, pakiet z sieci). Nie zużywa CPU.</li>
        <li><strong>D (Uninterruptible Sleep):</strong> Bardzo ważne. Proces czeka na sprzęt (I/O dysku). Nie da się go ubić <code>kill -9</code>, dopóki dysk nie odpowie. Wysokie Load Average przy niskim użyciu CPU często oznacza dużo procesów w stanie D (problem z dyskiem/NFS).</li>
        <li><strong>Z (Zombie):</strong> Proces zakończył działanie, zwolnił pamięć, ale wciąż wisi w tabeli procesów. Dlaczego? Bo rodzic nie odebrał jego kodu wyjścia (przez <code>wait()</code>). Zombie nie zużywa RAM ani CPU, tylko wpis w tabeli PID.</li>
    </ul>

    <h3 style="color: #333;">4. Wątki (Threads) – "Lekkie Procesy"</h3>
    <ul>
        <li><strong>Współdzielenie:</strong> Wątki w obrębie jednego procesu widzą tę samą pamięć (zmienne globalne). Zmiana zmiennej w wątku A jest widoczna w wątku B.</li>
        <li><strong>Linux implementation:</strong> Dla jądra Linux wątek to po prostu proces, który współdzieli tablicę stron pamięci z innym procesem (LWP - Light Weight Process).</li>
        <li><strong>Planowanie:</strong> Scheduler jądra przydziela czas procesora wątkom, a nie "procesom" jako całości.</li>
    </ul>

    <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

    <h2 style="color: #0056b3;">CZĘŚĆ III: System Plików (VFS, Inody, Montowanie)</h2>
    <p>Pytania o <code>/etc/fstab</code>, noexec, <code>/home</code> i strukturę katalogów.</p>

    <h3 style="color: #333;">1. VFS (Virtual File System)</h3>
    <p>Linux używa warstwy abstrakcji. Dla aplikacji nie ma znaczenia, czy plik leży na dysku SSD (ext4), w sieci (NFS), czy w pamięci RAM (tmpfs). Wszystko wygląda jak drzewo katalogów.</p>

    <h3 style="color: #333;">2. I-węzeł (Inode) – Fizyczna reprezentacja pliku</h3>
    <p>Plik w Linuxie składa się z dwóch części:</p>
    <ul>
        <li><strong>Nazwa:</strong> Przechowywana w "katalogu" (katalog to tylko mapa: Nazwa -> Numer Inoda).</li>
        <li><strong>Inode (Metadane):</strong> Przechowuje rozmiar, uprawnienia, właściciela, czasy (atime, mtime, ctime) i wskaźniki do bloków z danymi na dysku.</li>
    </ul>
    <p><em>Uwaga:</em> Inode nie przechowuje nazwy pliku.</p>

    <h3 style="color: #333;">3. Twarde i Miękkie Dowiązania (Hard vs Soft Links)</h3>
    <ul>
        <li><strong>Hard Link:</strong> Druga nazwa wskazująca na ten sam numer Inoda. Usunięcie oryginału nie usuwa danych, dopóki istnieje hard link. Nie działają między partycjami.</li>
        <li><strong>Soft Link (Symlink):</strong> Nowy plik (nowy Inode), który zawiera w środku ścieżkę do innego pliku. Jeśli usuniesz cel, symlink staje się "sierotą" (broken link).</li>
    </ul>

    <h3 style="color: #333;">4. Montowanie i /etc/fstab</h3>
    <p><strong>Montowanie:</strong> Kernel łączy system plików z urządzenia (np. <code>/dev/sda1</code>) z katalogiem (np. <code>/home</code>).</p>
    <p><strong>Opcje montowania (Security):</strong></p>
    <ul>
        <li><code>noexec</code>: Jądro odmawia wykonania wywołania <code>exec()</code> na plikach z tej partycji. Idealne dla <code>/tmp</code> i <code>/home</code> (ochrona przed malwarem).</li>
        <li><code>nodev</code>: Ignorowanie plików urządzeń (block/character devices) na partycji.</li>
        <li><code>nosuid</code>: Ignorowanie bitu SUID (kluczowe dla bezpieczeństwa pendrive'ów).</li>
    </ul>
    <p><strong>Awaria fstab:</strong> Podczas startu systemd parsuje <code>/etc/fstab</code>. Jeśli napotka błąd (zły UUID, literówka) i partycja nie jest oznaczona jako <code>nofail</code>, system wchodzi w Emergency Mode, aby zapobiec uszkodzeniu danych. Usługi sieciowe nie startują w tym trybie.</p>

    <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

    <h2 style="color: #0056b3;">CZĘŚĆ IV: Uprawnienia i Kontrola Dostępu</h2>
    <p>Pytania o root, sudo, DAC, MAC.</p>

    <h3 style="color: #333;">1. DAC (Discretionary Access Control) – Szczegóły</h3>
    <ul>
        <li><strong>Reprezentacja numeryczna (Octal):</strong> r=4, w=2, x=1.
            <br><code>chmod 750</code> -> Właściciel (7=rwx), Grupa (5=r-x), Inni (0=---).
        </li>
        <li><strong>Znaczenie x dla katalogu:</strong>
            <ul>
                <li>Dla pliku x to prawo uruchomienia.</li>
                <li>Dla katalogu x to prawo wejścia do środka (<code>cd</code>) i dostępu do metadanych plików wewnątrz (ale do wylistowania nazw plików potrzebujesz r).</li>
            </ul>
        </li>
        <li><strong>Bity specjalne:</strong>
            <ul>
                <li><em>SUID (Set User ID):</em> Plik wykonywalny uruchamia się z uprawnieniami właściciela pliku, a nie użytkownika uruchamiającego. Przykład: <code>/usr/bin/passwd</code> musi być rootem, by zmienić <code>/etc/shadow</code>, mimo że uruchamia go zwykły Jan. To główne źródło eskalacji uprawnień.</li>
                <li><em>Sticky Bit (t):</em> Na katalogu (np. <code>/tmp</code>). Pozwala usuwać pliki tylko ich właścicielom, mimo że katalog ma uprawnienia zapisu dla wszystkich (777).</li>
            </ul>
        </li>
    </ul>

    <h3 style="color: #333;">2. MAC (Mandatory Access Control) – SELinux/AppArmor</h3>
    <p>W modelu DAC, jeśli zawirusujesz Firefoksa (działającego jako Ty), wirus ma dostęp do Twoich zdjęć i dokumentów.</p>
    <p>W modelu MAC (np. SELinux):</p>
    <ul>
        <li>Każdy proces i plik ma kontekst (etykietę).</li>
        <li>Polityka w jądrze mówi: "Proces typu <code>httpd_t</code> może czytać tylko pliki typu <code>httpd_sys_content_t</code> i słuchać na porcie 80".</li>
    </ul>
    <p>Nawet jeśli Apache działa jako root (teoretycznie), SELinux zablokuje mu dostęp do <code>/etc/shadow</code>, bo polityka tego zabrania. To jest ta "niezależna warstwa".</p>

    <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

    <h2 style="color: #0056b3;">CZĘŚĆ V: Systemd – Zarządzanie Systemem</h2>
    <p>Pytania o targety, zależności, enabled/active.</p>

    <h3 style="color: #333;">1. Architektura Systemd</h3>
    <p>To nie tylko init. To platforma zarządzająca systemem. Używa cgroups (Control Groups) do śledzenia procesów i limitowania ich zasobów (CPU/RAM). Dzięki temu systemd wie, że procesy potomne Apache należą do usługi <code>apache2.service</code> i może ubić je wszystkie naraz.</p>

    <h3 style="color: #333;">2. Jednostki (Units) – Typy</h3>
    <ul>
        <li><strong>Service:</strong> Usługa/Demon.</li>
        <li><strong>Socket:</strong> Gniazdo. Systemd nasłuchuje na porcie (np. 22). Gdy przyjdzie pakiet, dopiero wtedy uruchamia usługę (Socket Activation). Oszczędza RAM.</li>
        <li><strong>Target:</strong> Punkt synchronizacji.
            <ul>
                <li><code>graphical.target</code> = dawny runlevel 5 (GUI).</li>
                <li><code>multi-user.target</code> = dawny runlevel 3 (CLI + Sieć).</li>
                <li><code>rescue.target</code> = tryb ratunkowy (single user, montuje dyski r/o).</li>
                <li><code>emergency.target</code> = tryb awaryjny (minimalny shell, dyski r/o, brak sieci).</li>
            </ul>
        </li>
    </ul>

    <h3 style="color: #333;">3. Zależności – "Dlaczego system nie wstał?"</h3>
    <ul>
        <li><code>Requires=</code> (Wymaga): Jeśli A wymaga B, a B zawiedzie przy starcie, A też zostanie wyłączone. To jest "mocna" zależność.</li>
        <li><code>Wants=</code> (Chce): Jeśli A chce B, a B zawiedzie, A i tak spróbuje wystartować. To "słaba" zależność.</li>
        <li><code>After=/Before=</code>: To definiuje tylko czas. <code>After=network.target</code> nie znaczy, że sieć musi działać, tylko że usługa spróbuje wystartować po próbie startu sieci.</li>
    </ul>

    <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

    <h2 style="color: #0056b3;">CZĘŚĆ VI: Sieci w Linuxie</h2>
    <p>Pytania o podstawy, DNS, porty.</p>

    <h3 style="color: #333;">1. Warstwy i Konfiguracja</h3>
    <ul>
        <li><strong>Interfejs (Layer 2):</strong> Ma adres MAC. Widoczny w <code>ip link</code>.</li>
        <li><strong>IP (Layer 3):</strong> Adres logiczny. Widoczny w <code>ip addr</code>.</li>
        <li><strong>Routing:</strong> Decyzja, gdzie wysłać pakiet. <code>ip route</code>. Jeśli cel nie jest w sieci lokalnej (określonej maską), pakiet leci do Bramy Domyślnej (0.0.0.0/0).</li>
    </ul>

    <h3 style="color: #333;">2. DNS – /etc/resolv.conf</h3>
    <p>System nie "wie", gdzie jest google.com. Pyta serwera DNS zdefiniowanego w <code>/etc/resolv.conf</code> (lub przez systemd-resolved).</p>
    <p>Kolejność rozwiązywania nazw: Najpierw <code>/etc/hosts</code>, potem DNS.</p>

    <h3 style="color: #333;">3. Porty i Gniazda (Sockets)</h3>
    <p>Proces sieciowy musi wykonać <code>bind()</code> (zarezerwować port) i <code>listen()</code> (nasłuchiwać).</p>
    <p>Porty < 1024 są uprzywilejowane – może je otworzyć tylko root. Dlatego Apache (port 80) startuje jako root, a potem zrzuca uprawnienia do użytkownika www-data (bezpieczeństwo).</p>

    <h3 style="color: #333;">4. Netfilter (Firewall)</h3>
    <p>Zapora sieciowa (iptables/nftables) jest modułem jądra.</p>
    <p>Może decydować o losie pakietu na podstawie: IP źródła, IP celu, portu, stanu połączenia (NEW, ESTABLISHED).</p>
    <p><strong>Connection Tracking:</strong> Linux pamięta, że pakiet przychodzący jest odpowiedzią na Twoje zapytanie, więc wpuszcza go, nawet jeśli domyślnie blokuje ruch przychodzący.</p>

    <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

    <h2 style="color: #0056b3;">CZĘŚĆ VII: Praktyka Administratora (Monitoring i Diagnostyka)</h2>

    <h3 style="color: #333;">1. Analiza Wydajności</h3>
    <ul>
        <li><strong>Load Average:</strong> Średnia liczba procesów, które chcą użyć CPU lub czekają na I/O (stan D). Jeśli Load > liczba rdzeni CPU, masz "korek".</li>
        <li><strong>Pamięć:</strong>
            <ul>
                <li><code>free -h</code>.</li>
                <li><em>Cache/Buffer:</em> Linux używa "wolnego" RAMu do cache'owania dysku. To dobrze. Pamięć ta jest zwalniana natychmiast, gdy aplikacja jej potrzebuje. Nie panikuj, że "wolny RAM" jest niski.</li>
            </ul>
        </li>
    </ul>

    <h3 style="color: #333;">2. Logi – /var/log</h3>
    <ul>
        <li><strong>Syslog:</strong> Tradycyjny system tekstowy (<code>/var/log/syslog</code> lub messages).</li>
        <li><strong>Journald:</strong> Binarny system logowania systemd.
            <ul>
                <li><code>journalctl -u nginx.service</code> – pokaż logi konkretnej usługi.</li>
                <li><code>journalctl -b -1</code> – pokaż logi z poprzedniego uruchomienia systemu (przed restartem).</li>
            </ul>
        </li>
        <li>Logi binarne są trudniejsze do sfałszowania przez hakera (zawierają sumy kontrolne).</li>
    </ul>

    <h3 style="color: #333;">3. Aktualizacje</h3>
    <p>Regularność to bezpieczeństwo.</p>
    <ul>
        <li><strong>CVE (Common Vulnerabilities and Exposures):</strong> Baza znanych podatności. Administrator sprawdza, czy jego kernel/usługi mają znane CVE i instaluje poprawki.</li>
    </ul>

</div>
<script>
    // --- BAZA DANYCH PYTAŃ (ZGODNA Z TREŚCIĄ ZADANIA) ---
    // Wszystkie pytania są traktowane jako "Wybierz wszystkie poprawne" (multi)
    // Opcje c: true są ustawione na podstawie sekcji "poprawne odpowiedzi" z promptu.
    
    const rawQuestions = [
        {
            id: 1, text: "Jakie skutki może mieć zamontowanie systemu plików z opcją noexec?",
            options: [
                { t: "Wpływa na prawa odczytu plików.", c: false },
                { t: "Uniemożliwia wykonywanie plików binarnych.", c: true },
                { t: "Ogranicza możliwość uruchamiania złośliwego kodu.", c: true },
                { t: "Powoduje błędy zapisu danych.", c: false }
            ]
        },
        {
            id: 2, text: "Które zadania należą do obowiązków administratora systemu Linux/Unix?",
            options: [
                { t: "Tworzenie aplikacji użytkowych.", c: false },
                { t: "Zarządzanie kontami użytkowników.", c: true },
                { t: "Konfiguracja usług systemowych.", c: true },
                { t: "Kompilacja jądra przy każdej aktualizacji.", c: false }
            ]
        },
        {
            id: 3, text: "Które elementy są niezbędne do podstawowej komunikacji sieciowej hosta?",
            options: [
                { t: "Interfejs sieciowy.", c: true },
                { t: "Brama domyślna.", c: true },
                { t: "System plików.", c: false },
                { t: "Adres IP.", c: true }
            ]
        },
        {
            id: 4, text: "Jakie ryzyka niesie za sobą ręczna modyfikacja plików konfiguracyjnych bez dokumentowania zmian?",
            options: [
                { t: "Utrudnioną diagnostykę błędów.", c: true },
                { t: "Zwiększenie czytelności konfiguracji.", c: false },
                { t: "Problemy podczas aktualizacji lub migracji systemu.", c: true },
                { t: "Trudności w odtworzeniu konfiguracji systemu.", c: true }
            ]
        },
        {
            id: 5, text: "Dlaczego błędy w pliku /etc/fstab są szczególnie niebezpieczne?",
            options: [
                { t: "Mogą powodować długie opóźnienia startu systemu (timeout montowania).", c: true },
                { t: "Mogą uniemożliwić poprawne uruchomienie systemu.", c: true },
                { t: "Powodują automatyczną i nieodwracalną utratę danych.", c: false },
                { t: "Uniemożliwiają aktualizację jądra systemu.", c: false }
            ]
        },
        {
            id: 6, text: "Dlaczego zasada najmniejszych uprawnień jest fundamentem bezpieczeństwa systemów Linux?",
            options: [
                { t: "Ogranicza skutki błędów użytkowników i usług.", c: true },
                { t: "Upraszcza zarządzanie pakietami systemowymi.", c: false },
                { t: "Zmniejsza zakres potencjalnych wektorów ataku.", c: true },
                { t: "Wspiera wielowarstwowy model ochrony systemu.", c: true }
            ]
        },
        {
            id: 7, text: "Jakie mogą być skutki błędnej konfiguracji zależności między jednostkami systemd?",
            options: [
                { t: "System może przejść w tryb awaryjny.", c: true },
                { t: "Może dojść do niedostępności kluczowych usług.", c: true },
                { t: "Zawsze następuje automatyczny restart systemu.", c: false },
                { t: "Usługi mogą uruchamiać się w niewłaściwej kolejności.", c: true }
            ]
        },
        {
            id: 8, text: "Które elementy wpływają na możliwość nawiązywania połączeń sieciowych przez proces?",
            options: [
                { t: "Konfiguracja sieci systemu.", c: true },
                { t: "Uprawnienia użytkownika, z którym działa proces.", c: true },
                { t: "Konfiguracja zapory sieciowej.", c: true },
                { t: "Typ systemu plików.", c: false }
            ]
        },
        {
            id: 9, text: "Dlaczego system logów jest kluczowym elementem administracji systemem Linux?",
            options: [
                { t: "Umożliwia analizę przyczyn awarii i incydentów.", c: true },
                { t: "Eliminuje potrzebę testowania zmian.", c: false },
                { t: "Zastępuje narzędzia monitorujące.", c: false },
                { t: "Pozwala śledzić działania użytkowników i usług.", c: true }
            ]
        },
        {
            id: 10, text: "W systemie Debian 13 zmiana konfiguracji usługi nie przynosi efektu. Co należy sprawdzić w pierwszej kolejności?",
            options: [
                { t: "Czy usługa została ponownie uruchomiona.", c: true },
                { t: "Czy system został zaktualizowany.", c: false },
                { t: "Czy użytkownik posiada konto w systemie.", c: false },
                { t: "Czy zmiany zapisano w odpowiednim pliku konfiguracyjnym.", c: true }
            ]
        },
        {
            id: 11, text: "Które stwierdzenia dotyczące katalogu głównego / są prawdziwe?",
            options: [
                { t: "Jest najwyższym poziomem hierarchii systemu plików.", c: true },
                { t: "Jest punktem montowania innych systemów plików.", c: true },
                { t: "Zawiera pliki konfiguracyjne użytkownika.", c: false },
                { t: "Może zostać usunięty po zamontowaniu /home.", c: false }
            ]
        },
        {
            id: 12, text: "Jaką rolę pełni mechanizm sudo?",
            options: [
                { t: "Umożliwia czasowe podniesienie uprawnień.", c: true },
                { t: "Pozwala wykonywać polecenia z uprawnieniami administratora.", c: true },
                { t: "Zastępuje konto root.", c: false },
                { t: "Działa bez wcześniejszej konfiguracji.", c: false }
            ]
        },
        {
            id: 13, text: "Które stwierdzenia dotyczące jądra systemu operacyjnego są prawdziwe?",
            options: [
                { t: "Jest uruchamiane jako zwykły proces użytkownika.", c: false },
                { t: "Zarządza dostępem do zasobów sprzętowych.", c: true },
                { t: "Odpowiada za interfejs graficzny użytkownika.", c: false },
                { t: "Pośredniczy w dostępie procesów do pamięci.", c: true }
            ]
        },
        {
            id: 14, text: "Które elementy składają się na model uprawnień DAC w systemie Linux?",
            options: [
                { t: "Właściciel pliku.", c: true },
                { t: "Kontekst bezpieczeństwa SELinux.", c: false },
                { t: "Prawa dostępu.", c: true },
                { t: "Grupa pliku.", c: true }
            ]
        },
        {
            id: 15, text: "Które funkcje pełni system plików w systemie Linux?",
            options: [
                { t: "Organizuje dane na nośnikach pamięci.", c: true },
                { t: "Umożliwia hierarchiczną strukturę katalogów.", c: true },
                { t: "Odpowiada za planowanie procesów.", c: false },
                { t: "Zapewnia mechanizmy kontroli dostępu do plików.", c: true }
            ]
        },
        {
            id: 16, text: "Dlaczego wykonywanie kopii zapasowych konfiguracji jest istotne w administracji systemami Linux?",
            options: [
                { t: "Pozwala cofnąć nieudane zmiany konfiguracyjne.", c: true },
                { t: "Umożliwia szybkie odtworzenie systemu po awarii.", c: true },
                { t: "Wspiera ciągłość działania usług.", c: true },
                { t: "Eliminuje potrzebę testowania zmian.", c: false }
            ]
        },
        {
            id: 17, text: "Jaką funkcję pełni system DNS?",
            options: [
                { t: "Tłumaczy nazwy domenowe na adresy IP.", c: true },
                { t: "Zarządza routingiem pakietów.", c: false },
                { t: "Zapewnia szyfrowanie połączeń.", c: false },
                { t: "Umożliwia wskazanie hosta lub usługi na podstawie nazwy.", c: true }
            ]
        },
        {
            id: 18, text: "Dlaczego uruchamianie usług sieciowych z uprawnieniami root jest uznawane za ryzykowne?",
            options: [
                { t: "Zmniejsza wydajność systemu.", c: false },
                { t: "Kompromitacja usługi może prowadzić do pełnego przejęcia systemu.", c: true },
                { t: "Zwiększa potencjalne skutki błędów konfiguracji.", c: true },
                { t: "Narusza zasadę najmniejszych uprawnień.", c: true }
            ]
        },
        {
            id: 19, text: "Które konsekwencje może mieć błędny wpis w pliku /etc/fstab?",
            options: [
                { t: "System plików może zostać zamontowany w trybie tylko do odczytu.", c: true },
                { t: "Jądro zostanie automatycznie zaktualizowane.", c: false },
                { t: "Usługi sieciowe przestaną działać.", c: false },
                { t: "System może nie uruchomić się poprawnie.", c: true }
            ]
        },
        {
            id: 20, text: "Dlaczego w systemach Linux proces potomny dziedziczy deskryptory plików po procesie rodzicu?",
            options: [
                { t: "Umożliwia to przekazywanie strumieni danych między procesami.", c: true },
                { t: "Jest wymagane przez system plików.", c: false },
                { t: "Zapobiega wyciekom pamięci.", c: false },
                { t: "Pozwala na dalsze korzystanie z już otwartych zasobów.", c: true }
            ]
        },
        {
            id: 21, text: "Które stwierdzenia poprawnie opisują różnicę między enabled a active w systemd?",
            options: [
                { t: "Usługa aktywna zawsze jest włączona.", c: false },
                { t: "enabled określa, czy usługa uruchamia się przy starcie systemu.", c: true },
                { t: "Usługa włączona zawsze jest aktywna.", c: false },
                { t: "active oznacza, że usługa aktualnie działa.", c: true }
            ]
        },
        {
            id: 22, text: "Dlaczego restart pojedynczej usługi jest często preferowany zamiast restartu całego systemu?",
            options: [
                { t: "Ogranicza wpływ zmian do konkretnego komponentu.", c: true },
                { t: "Minimalizuje przerwę w dostępności usług.", c: true },
                { t: "Eliminuje potrzebę analizy logów.", c: false },
                { t: "Zawsze rozwiązuje wszystkie problemy systemowe.", c: false }
            ]
        },
        {
            id: 23, text: "Dlaczego mechanizmy MAC są stosowane równolegle z DAC w systemach Linux?",
            options: [
                { t: "Zastępują klasyczne prawa plików.", c: false },
                { t: "Upraszczają konfigurację systemu.", c: false },
                { t: "Ograniczają skutki przejęcia kont użytkowników lub usług.", c: true },
                { t: "Zapewniają dodatkową, niezależną warstwę kontroli dostępu.", c: true }
            ]
        },
        {
            id: 24, text: "Dlaczego monitorowanie systemu jest istotnym elementem administracji?",
            options: [
                { t: "Eliminuje potrzebę dokumentowania zmian.", c: false },
                { t: "Zastępuje mechanizmy kopii zapasowych.", c: false },
                { t: "Pozwala analizować długoterminowe trendy obciążenia.", c: true },
                { t: "Umożliwia wykrywanie problemów zanim wpłyną na użytkowników.", c: true }
            ]
        },
        {
            id: 25, text: "Dlaczego wydzielenie katalogu /home do osobnego systemu plików jest dobrą praktyką administracyjną?",
            options: [
                { t: "Ułatwia reinstalację systemu bez utraty danych użytkowników.", c: true },
                { t: "Zwiększa szybkość działania aplikacji użytkownika.", c: false },
                { t: "Pozwala stosować inne opcje montowania niż dla systemu głównego.", c: true },
                { t: "Eliminuje potrzebę wykonywania kopii zapasowych.", c: false }
            ]
        },
        {
            id: 26, text: "Dlaczego regularne aktualizacje systemu są kluczowe z punktu widzenia bezpieczeństwa?",
            options: [
                { t: "Usuwają znane podatności bezpieczeństwa.", c: true },
                { t: "Zmniejszają ryzyko wykorzystania znanych exploitów.", c: true },
                { t: "Eliminują potrzebę tworzenia kopii zapasowych.", c: false },
                { t: "Mogą wprowadzać poprawki w mechanizmach ochrony systemu.", c: true }
            ]
        },
        {
            id: 27, text: "Dlaczego w systemach Linux zaleca się korzystanie z sudo zamiast bezpośredniego logowania na konto root?",
            options: [
                { t: "Eliminuje potrzebę istnienia konta root.", c: false },
                { t: "Umożliwia rejestrowanie i audyt wykonywanych poleceń.", c: true },
                { t: "Ogranicza czas trwania podwyższonych uprawnień.", c: true },
                { t: "Upraszcza konfigurację kont użytkowników.", c: false }
            ]
        },
        {
            id: 28, text: "Które problemy mogą wystąpić przy błędnej konfiguracji jednostki typu service?",
            options: [
                { t: "Usługa nie uruchomi się po starcie systemu.", c: true },
                { t: "System może przejść w tryb awaryjny.", c: true },
                { t: "Usługa zawsze zostanie automatycznie zrestartowana.", c: false },
                { t: "Konfiguracja interfejsów sieciowych przestanie działać.", c: false }
            ]
        },
        {
            id: 29, text: "Które stwierdzenia dotyczące konta root są prawdziwe?",
            options: [
                { t: "Nie może być zastąpione przez mechanizm sudo.", c: false },
                { t: "Może być bezpiecznie używane do codziennej pracy.", c: false },
                { t: "Posiada nieograniczone uprawnienia w systemie.", c: true },
                { t: "Jest przeznaczone do administracji systemem.", c: true }
            ]
        },
        {
            id: 30, text: "Które cechy charakteryzują wątki w systemach Unix/Linux?",
            options: [
                { t: "Wątki są planowane przez jądro systemu.", c: true },
                { t: "Wątki umożliwiają równoległe wykonywanie zadań.", c: true },
                { t: "Każdy wątek posiada niezależną przestrzeń adresową.", c: false },
                { t: "Wątki współdzielą przestrzeń adresową procesu.", c: true }
            ]
        },
        {
            id: 31, text: "Za co odpowiada planista (scheduler) w systemie Linux?",
            options: [
                { t: "Zarządza strukturą systemu plików.", c: false },
                { t: "Przydziela czas procesora procesom.", c: true },
                { t: "Decyduje o kolejności wykonywania procesów.", c: true },
                { t: "Odpowiada za ładowanie modułów jądra.", c: false }
            ]
        },
        {
            id: 32, text: "Jakie korzyści daje stosowanie mechanizmów MAC (np. SELinux) w systemach Linux?",
            options: [
                { t: "Zastępuje klasyczne prawa dostępu do plików.", c: false },
                { t: "Upraszcza zarządzanie użytkownikami.", c: false },
                { t: "Wprowadza politykę bezpieczeństwa niezależną od modelu DAC.", c: true },
                { t: "Ogranicza skutki przejęcia konta lub usługi.", c: true }
            ]
        },
        {
            id: 33, text: "Które elementy powinny być uwzględnione przy projektowaniu bezpiecznego systemu Linux?",
            options: [
                { t: "Minimalizacja liczby uruchomionych usług.", c: true },
                { t: "Regularne aktualizacje systemu.", c: true },
                { t: "Użycie jednego wspólnego konta administracyjnego.", c: false },
                { t: "Stosowanie zasady najmniejszych uprawnień.", c: true }
            ]
        },
        {
            id: 34, text: "Które elementy świadczą o dojrzałym podejściu do administracji systemem Linux?",
            options: [
                { t: "Świadome i systematyczne zarządzanie bezpieczeństwem.", c: true },
                { t: "Monitorowanie oraz dokumentowanie zmian.", c: true },
                { t: "Ręczna konfiguracja każdego elementu systemu.", c: false },
                { t: "Automatyzacja powtarzalnych zadań administracyjnych.", c: true }
            ]
        },
        {
            id: 35, text: "Po restarcie systemu Debian 13 usługa nie uruchamia się automatycznie. Które przyczyny są możliwe?",
            options: [
                { t: "Usługa jest jednostką typu static.", c: true },
                { t: "Usługa nie została włączona do startu systemu.", c: true },
                { t: "Brak połączenia z Internetem.", c: false },
                { t: "Jednostka systemd zawiera błędną konfigurację.", c: true }
            ]
        },
        {
            id: 36, text: "Które elementy wpływają na bezpieczeństwo systemu Linux?",
            options: [
                { t: "Konfiguracja usług.", c: true },
                { t: "Model uprawnień.", c: true },
                { t: "Wyłącznie hasła użytkowników.", c: false },
                { t: "Wyłącznie zapora sieciowa.", c: false }
            ]
        },
        {
            id: 37, text: "Które stwierdzenia dotyczące systemd są prawdziwe?",
            options: [
                { t: "Zarządza usługami systemowymi.", c: true },
                { t: "Umożliwia definiowanie zależności między jednostkami.", c: true },
                { t: "Odpowiada za kompilację jądra.", c: false },
                { t: "Jest systemem init.", c: true }
            ]
        },
        {
            id: 38, text: "Jakie zagrożenia może powodować niekontrolowane uruchamianie usług przy starcie systemu?",
            options: [
                { t: "Zwiększenie przepustowości sieci.", c: false },
                { t: "Wydłużenie czasu uruchamiania systemu.", c: true },
                { t: "Utrudnioną diagnostykę problemów systemowych.", c: true },
                { t: "Zwiększenie powierzchni ataku systemu.", c: true }
            ]
        },
        {
            id: 39, text: "Które czynniki należy uwzględnić przy aktualizacji systemu Debian 13 na serwerze produkcyjnym?",
            options: [
                { t: "Konieczność restartu usług lub systemu.", c: true },
                { t: "Możliwość przerwy w dostępności usług.", c: true },
                { t: "Zgodność konfiguracji po aktualizacji.", c: true },
                { t: "Aktualną temperaturę procesora.", c: false }
            ]
        },
        {
            id: 40, text: "Dlaczego usługi sieciowe często działają na dedykowanych kontach systemowych?",
            options: [
                { t: "Zmniejsza skutki ewentualnego przejęcia usługi.", c: true },
                { t: "Upraszcza konfigurację systemu DNS.", c: false },
                { t: "Zwiększa wydajność sieci.", c: false },
                { t: "Ogranicza to ich uprawnienia.", c: true }
            ]
        },
        {
            id: 41, text: "Jakie konsekwencje może mieć brak monitorowania usług na serwerze produkcyjnym?",
            options: [
                { t: "Trudności w ocenie stabilności systemu.", c: true },
                { t: "Opóźnione wykrycie awarii.", c: true },
                { t: "Brak danych do analizy incydentów.", c: true },
                { t: "Zwiększenie dostępności systemu.", c: false }
            ]
        },
        {
            id: 42, text: "Do czego służy katalog /etc w systemie Linux?",
            options: [
                { t: "Przechowuje pliki konfiguracyjne systemu.", c: true },
                { t: "Przechowuje pliki binarne programów.", c: false },
                { t: "Jest wykorzystywany do konfiguracji usług.", c: true },
                { t: "Zawiera dane użytkowników.", c: false }
            ]
        },
        {
            id: 43, text: "Jaką rolę pełnią jednostki typu target w systemd?",
            options: [
                { t: "Grupują inne jednostki logicznie.", c: true },
                { t: "Zastępują klasyczne runlevele.", c: true },
                { t: "Odpowiadają za konfigurację sieci.", c: false },
                { t: "Są wykonywane jako procesy.", c: false }
            ]
        },
        {
            id: 44, text: "Które stwierdzenia dotyczące usług sieciowych są prawdziwe?",
            options: [
                { t: "Są zawsze uruchamiane z uprawnieniami root.", c: false },
                { t: "Usługi sieciowe działają jako procesy.", c: true },
                { t: "Mogą być zarządzane przez systemd.", c: true },
                { t: "Nie wymagają konfiguracji.", c: false }
            ]
        },
        {
            id: 45, text: "Które skutki może mieć błędna konfiguracja zapory sieciowej na serwerze?",
            options: [
                { t: "Narażenie systemu na ataki z sieci.", c: true },
                { t: "Utrudnienia w zdalnym zarządzaniu systemem.", c: true },
                { t: "Utrata dostępu do świadczonych usług.", c: true },
                { t: "Zwiększenie wydajności systemu.", c: false }
            ]
        },
        {
            id: 46, text: "Które stwierdzenia poprawnie opisują proces w systemie Linux?",
            options: [
                { t: "Proces jest instancją uruchomionego programu.", c: true },
                { t: "Proces nie posiada własnej przestrzeni adresowej.", c: false },
                { t: "Każdy proces posiada unikalny identyfikator PID.", c: true },
                { t: "Proces zawsze składa się z jednego wątku.", c: false }
            ]
        },
        {
            id: 47, text: "Które konsekwencje może mieć uruchomienie usługi systemowej z uprawnieniami root?",
            options: [
                { t: "Poprawę wydajności usługi.", c: false },
                { t: "Brak konieczności zarządzania uprawnieniami.", c: false },
                { t: "Dostęp usługi do wszystkich zasobów systemowych.", c: true },
                { t: "Zwiększenie potencjalnych skutków podatności w usłudze.", c: true }
            ]
        },
        {
            id: 48, text: "Które informacje są kluczowe przy analizie procesu zużywającego nadmierne zasoby systemowe?",
            options: [
                { t: "Nazwa systemu plików.", c: false },
                { t: "Zużycie pamięci.", c: true },
                { t: "Stan procesu.", c: true },
                { t: "Zużycie procesora.", c: true }
            ]
        },
        {
            id: 49, text: "Które prawa dostępu są definiowane dla plików w systemie Linux?",
            options: [
                { t: "Zapis.", c: true },
                { t: "Wykonanie.", c: true },
                { t: "Dziedziczenie.", c: false },
                { t: "Odczyt.", c: true }
            ]
        },
        {
            id: 50, text: "Dlaczego systemd wykorzystuje zależności między jednostkami?",
            options: [
                { t: "Aby zastąpić mechanizm kontroli dostępu DAC.", c: false },
                { t: "Aby kontrolować kolejność uruchamiania usług.", c: true },
                { t: "Aby ograniczyć zużycie pamięci.", c: false },
                { t: "Aby zapewnić dostępność wymaganych zasobów", c: true }
            ]
        }
    ];

    // Funkcja mieszająca (Fisher-Yates)
    function shuffle(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }

    // Renderowanie pytań
    function renderQuiz() {
        const quizArea = document.getElementById('quiz-area');
        // Mieszanie kolejności pytań
        const shuffledQuestions = shuffle([...rawQuestions]);

        shuffledQuestions.forEach((q, index) => {
            const card = document.createElement('div');
            card.className = 'q-card';
            
            // Nagłówek
            card.innerHTML = `<div class="q-header">
                <span>${index + 1}. ${q.text}</span>
                <span class="badge">Wielokrotny wybór</span>
            </div>`;

            // Kontener opcji
            const list = document.createElement('div');
            list.className = 'options-list';
            
            // Mieszanie opcji wewnątrz pytania
            const shuffledOptions = shuffle([...q.options]);

            shuffledOptions.forEach((opt) => {
                const label = document.createElement('label');
                label.className = 'opt-label';
                
                // Input checkbox
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.value = opt.c; // true/false jako string
                
                label.appendChild(input);
                // Usunięcie ewentualnych prefiksów "a.", "b." z tekstu dla estetyki po przemieszaniu
                const cleanText = opt.t.replace(/^[a-z]\.\s+/, '');
                label.appendChild(document.createTextNode(cleanText));
                
                list.appendChild(label);
            });

            card.appendChild(list);

            // Przycisk sprawdzania
            const btn = document.createElement('button');
            btn.className = 'btn-check';
            btn.innerText = 'Sprawdź odpowiedź';
            
            btn.onclick = () => {
                const inputs = list.querySelectorAll('input');
                let allCorrect = true;

                inputs.forEach(inp => {
                    const parent = inp.parentElement;
                    parent.classList.remove('correct', 'wrong', 'missed');
                    
                    const isCorrect = inp.value === 'true';
                    const isChecked = inp.checked;

                    if (isChecked) {
                        if (isCorrect) {
                            parent.classList.add('correct');
                        } else {
                            parent.classList.add('wrong');
                            allCorrect = false;
                        }
                    } else {
                        // Jeśli odpowiedź była poprawna, ale nie zaznaczona
                        if (isCorrect) {
                            parent.classList.add('missed');
                            allCorrect = false;
                        }
                    }
                });
                
                btn.innerText = allCorrect ? 'Świetnie! Poprawna odpowiedź' : 'Sprawdź poprawki';
                btn.style.background = allCorrect ? '#00b894' : '#e95420';
            };

            card.appendChild(btn);
            quizArea.appendChild(card);
        });
    }

    // Start
    renderQuiz();

</script>

</body>
</html>
