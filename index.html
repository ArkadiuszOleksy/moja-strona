<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulator Egzaminu ESI - Wersja Realistyczna</title>
    <style>
        :root { --primary: #0056b3; --bg: #f4f7f6; --tile-bg: #ffffff; --border: #dfe6e9; --correct: #27ae60; --wrong: #c0392b; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: var(--bg); color: #2d3436; margin: 0; padding: 20px; line-height: 1.5; }
        .container { max-width: 900px; margin: 0 auto; padding-bottom: 50px; }
        h1 { text-align: center; color: var(--primary); margin-bottom: 30px; }
        
        /* Kontener Pytania */
        .q-card { background: white; border-radius: 8px; padding: 25px; margin-bottom: 25px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); border-left: 5px solid var(--primary); }
        .q-header { font-weight: 700; font-size: 1.1em; margin-bottom: 15px; display: flex; justify-content: space-between; }
        .q-type { font-size: 0.8em; color: #636e72; font-weight: normal; background: #eee; padding: 2px 8px; border-radius: 4px; }

        /* Kafelki wyboru (Radio/Checkbox) */
        .options-grid { display: grid; gap: 10px; }
        .tile-option { border: 2px solid var(--border); border-radius: 6px; padding: 12px; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; }
        .tile-option:hover { background: #f9f9f9; border-color: #b2bec3; }
        .tile-option input { margin-right: 12px; transform: scale(1.2); }
        .tile-option.checked { border-color: var(--primary); background: #e3f2fd; }
        .tile-option.correct { border-color: var(--correct); background: #d4edda; color: #155724; }
        .tile-option.wrong { border-color: var(--wrong); background: #f8d7da; color: #721c24; }

        /* Pytania z lukami (Dropdown) */
        .gap-text { font-size: 1.1em; line-height: 2; }
        select.gap-select { padding: 5px; border: 2px solid var(--primary); border-radius: 4px; background: white; font-weight: bold; cursor: pointer; }
        select.gap-select.valid { border-color: var(--correct); background-color: #d4edda; }
        select.gap-select.invalid { border-color: var(--wrong); background-color: #f8d7da; }

        /* Drag & Drop - Kontenery */
        .dd-area { display: flex; gap: 20px; flex-wrap: wrap; margin-top: 15px; }
        .dd-source { flex: 1; min-width: 200px; background: #f1f2f6; padding: 10px; border-radius: 6px; border: 2px dashed #b2bec3; }
        .dd-targets { flex: 2; display: flex; flex-direction: column; gap: 10px; }
        .dd-zone { background: #eef2f3; border: 2px solid #ced6e0; border-radius: 6px; padding: 15px; min-height: 60px; }
        .dd-zone h4 { margin: 0 0 10px 0; font-size: 0.9em; color: var(--primary); text-transform: uppercase; }

        /* Kafelki do przeciągania */
        .draggable { background: white; border: 1px solid #bdc3c7; padding: 8px 12px; margin-bottom: 8px; border-radius: 4px; cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.05); user-select: none; }
        .draggable:active { cursor: grabbing; }
        .draggable.placed-correct { border-left: 5px solid var(--correct); }
        .draggable.placed-wrong { border-left: 5px solid var(--wrong); }

        /* Sortowanie (Ordering) */
        .sort-list { list-style: none; padding: 0; }
        .sort-item { background: white; border: 1px solid #dfe6e9; padding: 12px; margin-bottom: 5px; border-radius: 4px; display: flex; align-items: center; cursor: grab; }
        .sort-item::before { content: '☰'; margin-right: 10px; color: #b2bec3; }
        .sort-item.correct-order { border-color: var(--correct); background: #f0fff4; }

        /* Pytania otwarte */
        textarea.open-input { width: 100%; height: 80px; padding: 10px; border: 1px solid #bdc3c7; border-radius: 4px; margin-top: 10px; font-family: inherit; }
        .model-answer { display: none; margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeeba; border-radius: 4px; color: #856404; }

        /* Przyciski */
        .btn-check { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em; margin-top: 15px; }
        .btn-check:hover { background: #004494; }

        .feedback { margin-top: 10px; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h1>Symulator Egzaminu ESI</h1>
    <div id="quiz-root"></div>
</div>

<script>
    // Baza danych pytań (Zaktualizowana o typy interakcji)
    const questions = [
        // 1. Wybór wielokrotny
        { id: 1, type: 'multi', text: "Persony (jako fikcyjni użytkownicy) powinni obejmować informacje na temat ich cech, takich jak:", options: [
            { t: "scenariusze użycia", c: true }, { t: "cele", c: true }, { t: "demografia", c: true }, { t: "motywacje", c: true }, 
            { t: "koncepcje", c: false }, { t: "testy wyboru", c: false }, { t: "ryzyka", c: false }
        ]},
        // 2. Otwarte
        { id: 2, type: 'open', text: "Określ, jakie to kryterium użyteczności interfejsu użytkownika, które określa łatwość z jaką powracający użytkownicy mogą ponownie nauczyć się korzystania z aplikacji po dłuższej przerwie.", answer: "Zapamiętywalność (Memorability)" },
        // 3. Wybór jednokrotny
        { id: 3, type: 'single', text: "Co to jest projektowanie responsywne?", options: [
            { t: "Projektowanie stron internetowych, które dostosowują się do różnych urządzeń", c: true },
            { t: "Projektowanie widgetów interfejsu graficznego", c: false },
            { t: "Projektowanie interfejsów tylko dla komputerów stacjonarnych", c: false },
            { t: "Tworzenie statycznych stron internetowych", c: false }
        ]},
        // 4. Otwarte
        { id: 4, type: 'open', text: "Określ, jakie to kryterium użyteczności interfejsu użytkownika, które określa jak szybko nowi użytkownicy mogą osiągnąć biegłość w korzystaniu z aplikacji.", answer: "Łatwość nauki (Learnability)" },
        // 5. Wybór jednokrotny
        { id: 5, type: 'single', text: "Jakie są korzyści z testów A/B?", options: [
            { t: "Ocena i porównanie różnych wersji interfejsu", c: true },
            { t: "Zmniejszenie czasu ładowania strony", c: false },
            { t: "Zwiększenie estetyki interfejsu", c: false },
            { t: "Tworzenie dokumentacji technicznej", c: false }
        ]},
        // 6. Kategoryzacja (Drag & Drop)
        { id: 6, type: 'category', text: "Przeciągnij odpowiednie elementy do kategorii:", categories: ["Testy użyteczności", "Analiza heurystyczna"], items: [
            { t: "Testy z udziałem rzeczywistych użytkowników", cat: 0 },
            { t: "Ocena przez ekspertów", cat: 1 },
            { t: "Ocena przez użytkowników", cat: 0 }
        ]},
        // 7. Wybór jednokrotny
        { id: 7, type: 'single', text: "Dlaczego ważne są testy użyteczności?", options: [
            { t: "Aby ocenić łatwość obsługi i zrozumiałość interfejsu", c: true },
            { t: "Aby poprawić wydajność serwera", c: false },
            { t: "Aby zredukować liczbę linii kodu", c: false }
        ]},
        // 8. Wybór jednokrotny
        { id: 8, type: 'single', text: "Co to jest heatmap w kontekście testowania użyteczności?", options: [
            { t: "Wizualne przedstawienie danych użytkowników", c: true },
            { t: "Narzędzie do tworzenia grafiki", c: false },
            { t: "Protokół sieciowy", c: false }
        ]},
        // 9. Otwarte
        { id: 9, type: 'open', text: "Aby zapewnić czytelność i dostępność treści dla wszystkich użytkowników, w tym osób z wadami wzroku należy utrzymać na stronach internetowych wysoki...", answer: "Kontrast" },
        // 10. Kolejność (Sortable)
        { id: 10, type: 'order', text: "Ułóż w odpowiedniej kolejności przebieg scenariusza oceny jakości:", items: [
            "Zdefiniowanie celów biznesowych",
            "Identyfikacja użytkowników docelowych",
            "Projektowanie testów",
            "Przeprowadzenie testów",
            "Analiza wyników",
            "Wdrożenie poprawek",
            "Monitorowanie i ciągłe doskonalenie"
        ]},
        // 11. Wybór jednokrotny
        { id: 11, type: 'single', text: "Jakie są główne cele testów użyteczności?", options: [
            { t: "Ocena łatwości obsługi interfejsu", c: true },
            { t: "Zmniejszenie czasu projektowania interfejsu użytkownika", c: false },
            { t: "Ocena wydajności systemu", c: false }
        ]},
        // 12. Wybór jednokrotny
        { id: 12, type: 'single', text: "Jakie są korzyści z tworzenia person?", options: [
            { t: "Wszystkie wymienione odpowiedzi", c: true },
            { t: "Lepsze dopasowanie projektu do potrzeb użytkowników", c: false },
            { t: "Lepsze zrozumienie użytkowników", c: false }
        ]},
        // 13. Wybór jednokrotny
        { id: 13, type: 'single', text: "Co to jest wireframe?", options: [
            { t: "Uproszczony schematyczny model projektu strony", c: true },
            { t: "Analiza danych użytkowników", c: false },
            { t: "Szczegółowy projekt graficzny", c: false }
        ]},
        // 14. Otwarte
        { id: 14, type: 'open', text: "Wpisz jaki to rodzaj modelowania, jeśli polega on badaniu zachowania użytkowników w interakcji z systemem", answer: "Modelowanie behawioralne" },
        // 15. Kategoryzacja
        { id: 15, type: 'category', text: "Przeciągnij odpowiednie elementy do kategorii:", categories: ["Przykład UI", "Przykład UX"], items: [
            { t: "Przycisk", cat: 0 },
            { t: "Ikona", cat: 0 },
            { t: "Łatwość obsługi", cat: 1 },
            { t: "Zadowolenie użytkownika", cat: 1 }
        ]},
        // 16. Kategoryzacja/Dopasowanie
        { id: 16, type: 'category', text: "Dopasuj do narzędzia jego zastosowanie:", categories: ["Projektowanie graficzne", "Testowanie prototypów"], items: [
            { t: "Sketch", cat: 0 },
            { t: "Adobe XD", cat: 0 },
            { t: "Heatmap", cat: 1 },
            { t: "UsabilityHub", cat: 1 }
        ]},
        // 17. Kategoryzacja/Dopasowanie (Definicje)
        { id: 17, type: 'category', text: "Dopasuj definicje do pojęć:", 
            categories: ["UI", "UX", "Użyteczność", "Architektura Info"], items: [
            { t: "Zbiór elementów interfejsu (przyciski, pola)", cat: 0 },
            { t: "Całokształt doświadczeń (funkcjonalne, emocjonalne)", cat: 1 },
            { t: "Stopień efektywności, skuteczności i satysfakcji", cat: 2 },
            { t: "Sposób organizacji treści i nawigacji", cat: 3 }
        ]},
        // 18. Wybór wielokrotny
        { id: 18, type: 'multi', text: "Wskaż metody badania użyteczności interfejsu:", options: [
            { t: "Analiza heurystyczna", c: true }, { t: "Testy użytkowników", c: true }, { t: "Ankiety i wywiady", c: true },
            { t: "Ocena konstrukcji person", c: false }, { t: "Analiza wdrożenia", c: false }
        ]},
        // 19. Kolejność
        { id: 19, type: 'order', text: "Ułóż w odpowiedniej kolejności kluczowe etapy procesu projektowania interfejsu:", items: [
            "Badanie użytkowników", "Tworzenie person", "Projektowanie wstępne", "Prototypowanie", "Testowanie użyteczności", "Wdrażanie"
        ]},
        // 20. Single
        { id: 20, type: 'single', text: "Jakie są główne cele prototypowania?", options: [
            { t: "Testowanie i poprawianie wstępnych wersji produktu", c: true }, { t: "Tworzenie końcowej wersji produktu", c: false }, { t: "Analiza kodu źródłowego", c: false }
        ]},
        // 21. Single
        { id: 21, type: 'single', text: "Korzyści z wysokiego kontrastu kolorów?", options: [
            { t: "Poprawa czytelności", c: true }, { t: "Estetyczny wygląd", c: false }, { t: "Zmniejszenie czytelności", c: false }
        ]},
        // 22. Single
        { id: 22, type: 'single', text: "Co to jest UX?", options: [
            { t: "Ogólne doświadczenie użytkownika z aplikacją", c: true }, { t: "Kodowanie backendu", c: false }, { t: "Estetyka interfejsu", c: false }
        ]},
        // 23. Single
        { id: 23, type: 'single', text: "Co to jest analiza heurystyczna?", options: [
            { t: "Ocena interfejsu przez ekspertów na podstawie zasad", c: true }, { t: "Testowanie przez użytkowników", c: false }, { t: "Tworzenie prototypów", c: false }
        ]},
        // 24. Kategoryzacja (Złożona - uproszczona do logicznych par)
        { id: 24, type: 'category', text: "Dopasuj typy testów do opisów:", categories: ["Testy A/B", "Testy użyteczności", "Testy jednostkowe", "Testy akceptacyjne"], items: [
            { t: "Porównanie dwóch wersji interfejsu", cat: 0 },
            { t: "Ocena łatwości obsługi przez użytkowników", cat: 1 },
            { t: "Sprawdzenie poprawności kodu", cat: 2 },
            { t: "Zgodność ze specyfikacją wymagań", cat: 3 }
        ]},
        // 25. Single
        { id: 25, type: 'single', text: "Cel tworzenia person?", options: [
            { t: "Zrozumienie różnorodnych potrzeb użytkowników", c: true }, { t: "Optymalizacja kodu", c: false }
        ]},
        // 26. Dropdown (Luki)
        { id: 26, type: 'gap', text: "Celem [gap] jest zapewnienie [gap] obsługi dla użytkowników oraz [gap] potencjalnych problemów.", 
            parts: ["Celem ", " jest zapewnienie ", " obsługi dla użytkowników oraz ", " potencjalnych problemów."],
            answers: ["projektowania interakcji", "intuicyjnej, zrozumiałej, efektywnej", "identyfikacja"],
            options: ["projektowania interakcji", "klas", "intuicyjnej, zrozumiałej, efektywnej", "trudnej", "identyfikacja", "ocena", "wymagań"]
        },
        // 27. Dropdown
        { id: 27, type: 'gap', text: "W projektowaniu interfejsu jego [gap] to stopień, w jakim interfejs jest [gap] w użyciu, co pozwala na [gap] osiąganie celów.",
            parts: ["W projektowaniu interfejsu jego ", " to stopień, w jakim interfejs jest ", " w użyciu, co pozwala na ", " osiąganie celów."],
            answers: ["użyteczność", "łatwy i efektywny", "skuteczne i satysfakcjonujące"],
            options: ["użyteczność", "dostępność", "łatwy i efektywny", "ryzykowny", "skuteczne i satysfakcjonujące", "szkicowany"]
        },
        // 28. Single
        { id: 28, type: 'single', text: "Poprawna zasada w projektowaniu interfejsów:", options: [
            { t: "buduj interfejsy reaktywne, lub responsywne", c: true }, { t: "maksymalizacji obciążenia poznawczego", c: false }
        ]},
        // 29. Otwarte
        { id: 29, type: 'open', text: "Rodzaj modelowania polegający na projektowaniu fizycznych aspektów interfejsu (układ przycisków):", answer: "Modelowanie fizyczne" },
        // 30. Single
        { id: 30, type: 'single', text: "Co to jest makieta (mockup)?", options: [
            { t: "Szczegółowy projekt wizualny", c: true }, { t: "Działający kod", c: false }, { t: "Uproszczony schemat", c: false }
        ]},
        // 31. Otwarte
        { id: 31, type: 'open', text: "Narzędzie badawcze używane w ankietach do mierzenia postaw (stopień zgody):", answer: "Skala Likerta" },
        // 32. Dropdown
        { id: 32, type: 'gap', text: "[gap] jest procesem tworzenia [gap] produktu w celu ich [gap] przed finalnym wdrożeniem.",
            parts: ["", " jest procesem tworzenia ", " produktu w celu ich ", " przed finalnym wdrożeniem."],
            answers: ["Prototypowanie", "wstępnych wersji", "testowania"],
            options: ["Prototypowanie", "Kodowanie", "wstępnych wersji", "obrazów", "testowania", "modelowanie"]
        },
        // 33. Dropdown
        { id: 33, type: 'gap', text: "Analiza [gap] polega na jego ocenie przez [gap] na podstawie [gap].",
            parts: ["Analiza ", " polega na jego ocenie przez ", " na podstawie ", "."],
            answers: ["heurystyczna", "ekspertów", "ustalonych zasad"],
            options: ["heurystyczna", "dynamiczna", "ekspertów", "użytkowników", "ustalonych zasad", "twierdzeń"]
        },
        // 34. Otwarte
        { id: 34, type: 'open', text: "Rodzaj modelowania - badanie sposobu, w jaki użytkownicy myślą o interfejsie:", answer: "Modelowanie mentalne" }
    ];

    const root = document.getElementById('quiz-root');

    // Mieszanie tablicy
    function shuffle(array) {
        return array.sort(() => Math.random() - 0.5);
    }

    questions.forEach((q, idx) => {
        const card = document.createElement('div');
        card.className = 'q-card';
        
        let headerHTML = `<div class="q-header"><span>${idx+1}. ${q.text.replace(/\[gap\]/g, "...")}</span> <span class="q-type">${translateType(q.type)}</span></div>`;
        
        let contentHTML = '';

        // GENEROWANIE TREŚCI ZALEŻNIE OD TYPU
        if (q.type === 'single' || q.type === 'multi') {
            contentHTML = `<div class="options-grid">`;
            const opts = shuffle([...q.options]);
            opts.forEach((opt, oIdx) => {
                const inputType = q.type === 'single' ? 'radio' : 'checkbox';
                contentHTML += `
                    <label class="tile-option" id="q${q.id}_o${oIdx}">
                        <input type="${inputType}" name="q${q.id}" value="${opt.c}">
                        <span>${opt.t}</span>
                    </label>
                `;
            });
            contentHTML += `</div><button class="btn-check" onclick="checkChoice(${q.id}, '${q.type}')">Sprawdź</button>`;
        } 
        else if (q.type === 'open') {
            contentHTML = `
                <textarea class="open-input" placeholder="Wpisz odpowiedź..."></textarea>
                <div class="model-answer" id="ans-${q.id}">Wzorcowa odpowiedź: <strong>${q.answer}</strong></div>
                <button class="btn-check" onclick="document.getElementById('ans-${q.id}').style.display='block'">Pokaż wzorcową odpowiedź</button>
            `;
        }
        else if (q.type === 'gap') {
            headerHTML = `<div class="q-header"><span>${idx+1}. Uzupełnij luki:</span> <span class="q-type">Lista rozwijana</span></div>`;
            contentHTML = `<div class="gap-text">`;
            q.parts.forEach((part, i) => {
                contentHTML += part;
                if (i < q.parts.length - 1) {
                    let optsHTML = `<option value="">---</option>`;
                    shuffle([...q.options]).forEach(opt => optsHTML += `<option value="${opt}">${opt}</option>`);
                    contentHTML += `<select class="gap-select" data-ans="${q.answers[i]}">${optsHTML}</select>`;
                }
            });
            contentHTML += `</div><button class="btn-check" onclick="checkGaps(this)">Sprawdź</button>`;
        }
        else if (q.type === 'category') {
            // Drag and Drop Logic
            contentHTML = `<div class="dd-area"><div class="dd-source" id="src-${q.id}">`;
            shuffle([...q.items]).forEach((item, i) => {
                contentHTML += `<div class="draggable" draggable="true" data-cat="${item.cat}">${item.t}</div>`;
            });
            contentHTML += `</div><div class="dd-targets">`;
            q.categories.forEach((cat, i) => {
                contentHTML += `<div class="dd-zone" data-cat-id="${i}"><h4>${cat}</h4></div>`;
            });
            contentHTML += `</div></div><button class="btn-check" onclick="checkDrag(${q.id})">Sprawdź</button>`;
        }
        else if (q.type === 'order') {
            contentHTML = `<ul class="sort-list" id="sort-${q.id}">`;
            // Losujemy kolejność początkową (ale nie idealnie taką samą, chyba że shuffle zadziała)
            let mixed = shuffle([...q.items]); 
            // Jeśli przez przypadek wylosuje dobrą, mieszamy jeszcze raz (opcjonalne)
            
            mixed.forEach(item => {
                contentHTML += `<li class="sort-item" draggable="true">${item}</li>`;
            });
            contentHTML += `</ul><button class="btn-check" onclick="checkOrder(${q.id}, this)">Sprawdź kolejność</button>`;
        }

        card.innerHTML = headerHTML + contentHTML + `<div class="feedback" id="feed-${q.id}"></div>`;
        root.appendChild(card);
    });

    function translateType(type) {
        if(type === 'multi') return 'Wielokrotny wybór';
        if(type === 'single') return 'Jednokrotny wybór';
        if(type === 'open') return 'Pytanie otwarte';
        if(type === 'gap') return 'Uzupełnij luki';
        if(type === 'category') return 'Kategoryzacja';
        if(type === 'order') return 'Kolejność';
        return '';
    }

    // --- LOGIKA SPRAWDZANIA ---

    // 1. Wybór (Radio/Check)
    window.checkChoice = (id, type) => {
        const inputs = document.querySelectorAll(`input[name="q${id}"]`);
        inputs.forEach(inp => {
            const parent = inp.parentElement;
            parent.classList.remove('correct', 'wrong');
            if(inp.checked) {
                if(inp.value === 'true') parent.classList.add('correct');
                else parent.classList.add('wrong');
            } else if (type === 'multi' && inp.value === 'true') {
                // Opcjonalnie: pokaż, co powinno być zaznaczone
                 parent.style.border = "2px dashed #27ae60"; 
            }
        });
    };

    // 2. Luki (Gaps)
    window.checkGaps = (btn) => {
        const container = btn.previousElementSibling;
        const selects = container.querySelectorAll('select');
        selects.forEach(sel => {
            sel.classList.remove('valid', 'invalid');
            if(sel.value === sel.dataset.ans) sel.classList.add('valid');
            else sel.classList.add('invalid');
        });
    };

    // 3. Drag & Drop (Categories)
    // Inicjalizacja Drag & Drop Events
    document.addEventListener('dragstart', e => {
        if(e.target.classList.contains('draggable') || e.target.classList.contains('sort-item')) {
            e.dataTransfer.setData('text/plain', null); // Firefox fix
            e.target.classList.add('dragging');
        }
    });

    document.addEventListener('dragend', e => {
        if(e.target.classList.contains('dragging')) {
            e.target.classList.remove('dragging');
        }
    });

    document.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(e.target.closest('.dd-zone, .sort-list'), e.clientY);
        const dragging = document.querySelector('.dragging');
        if(!dragging) return;
        
        // Logika dla kategorii
        if(dragging.classList.contains('draggable')) {
            const zone = e.target.closest('.dd-zone');
            const source = e.target.closest('.dd-source');
            if (zone) zone.appendChild(dragging);
            if (source) source.appendChild(dragging);
        }
        
        // Logika dla sortowania
        if(dragging.classList.contains('sort-item')) {
            const list = e.target.closest('.sort-list');
            if(list) {
                if (afterElement == null) {
                    list.appendChild(dragging);
                } else {
                    list.insertBefore(dragging, afterElement);
                }
            }
        }
    });

    function getDragAfterElement(container, y) {
        if(!container) return null;
        const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging), .sort-item:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    window.checkDrag = (id) => {
        const zones = document.querySelectorAll(`.q-card:nth-child(${id}) .dd-zone`); // Uproszczony selektor, w realnym ID trzeba precyzyjniej
        // Znajdźmy kontener po ID przycisku - bezpieczniej
        const btn = event.target;
        const card = btn.closest('.q-card');
        const zonesInCard = card.querySelectorAll('.dd-zone');
        
        zonesInCard.forEach(zone => {
            const targetCat = zone.dataset.catId;
            const items = zone.querySelectorAll('.draggable');
            items.forEach(item => {
                item.classList.remove('placed-correct', 'placed-wrong');
                if(item.dataset.cat === targetCat) item.classList.add('placed-correct');
                else item.classList.add('placed-wrong');
            });
        });
    };

    window.checkOrder = (id, btn) => {
        const list = btn.previousElementSibling;
        const items = list.querySelectorAll('.sort-item');
        // Prawidłowa kolejność jest w obiekcie questions, musimy ją pobrać
        const qData = questions.find(q => q.id === id);
        
        items.forEach((item, index) => {
            item.classList.remove('correct-order');
            if(item.innerText === qData.items[index]) {
                item.classList.add('correct-order');
            } else {
                item.style.background = "#fff0f0";
            }
        });
    };

</script>

</body>
</html>
